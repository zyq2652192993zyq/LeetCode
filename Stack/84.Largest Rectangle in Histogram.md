> # 84.Largest Rectangle in Histogram

Tags: `Hard` `Stack`

Link: <https://leetcode.com/problems/largest-rectangle-in-histogram/>

---

Given *n* non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.

 

![img](https://assets.leetcode.com/uploads/2018/10/12/histogram.png)
Above is a histogram where width of each bar is 1, given height = `[2,1,5,6,2,3]`.

 

![img](https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png)
The largest rectangle is shown in the shaded area, which has area = `10` unit.

---

**Example:**

```
Input: [2,1,5,6,2,3]
Output: 10
```

---

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> s;
        heights.push_back(0);
        int result = 0;
        
        for(int i = 0; i < heights.size(); )
        {
            if(s.empty() || heights[i] > heights[s.top()])
                s.push(i++);
            else{
                int tmp = s.top();
                s.pop();
                result = max(result,heights[tmp] * (s.empty() ? i : i - s.top() - 1));
            }
        }
        
        return result;
    }
};
```

解析：

**辅助栈法**

根本思想是：依次遍历所有矩形条，尝试计算以该矩形条为高度的矩形面积。但是在遍历的时候我们不知道后面还有什么样的矩形条，对于没法确定面积的矩形，压栈，留着以后处理，而对于那些已经可以确定计算出面积的矩形条，留着也没用，弹栈。

如果我们能知道一个矩形条向左向右最远能延伸多远，我们就能计算出以该矩形条为高的矩形面积了！我们怎么知道向左向右能延伸多远？观察下面几种情况：

情况1，第`i`个矩形比右边相邻的第`i+1`个矩形高，如下图所示。意味着，以`height[i]`为高的矩形的右边界就是第`i`个矩形，因为右边界不能更右了，也不会在左边（向左只会让矩形面积减小）。所以在这种情况下，我们可以立即确定以第`i`个矩形的高度`height[i]`为高度的最大矩形面积的右边界。

![img](https://images0.cnblogs.com/blog/650745/201501/181927331046353.png)

情况2，第`i`个矩形比左边相邻的第`i-1`个矩形高，如下图所示。意味着，以`height[i]`为高的矩形的左边界就是第`i`个矩形，因为左边界不能更左了，也不会出现在右边（因为向右只会另矩形面积减小）。所以在这种情况下，我们立即就可以确定以第`i`个矩形的高度`height[i]`为高度的最大矩形面积的左边界。

![img](https://images0.cnblogs.com/blog/650745/201501/181932159795806.png)

现在，我们依次遍历各个矩形条，遍历过的矩形条压入栈中保存，则不难发现下面的现象：

如果当前矩形条的高度高于栈顶的矩形条的高度，对应上面的情况2，我们可以立即得出，当前矩形一定是以它为高的矩形的左边界。那么现在我们还不能确定其右边界，所以除了入栈什么都不用做，如下图所示：

![img](https://images0.cnblogs.com/blog/650745/201501/181611557143280.png)

如果当前矩形条的高度小于或等于栈顶矩形条的高度，对应上面的情况1，我们可以立即得出：栈顶的矩形一定是以它为高的矩形的右边界所以，我们可以立刻得到以栈顶的矩形条高度为高度的最大矩形的面积（下图中带颜色的两个矩形）！既然我们算出了前一个条最大矩形的面积，那么也就没必要再留着它了。所以，可以放心把它删掉，或者说合并。

![img](https://images0.cnblogs.com/blog/650745/201501/181617294648242.png)

![img](https://images0.cnblogs.com/blog/650745/201501/181621381363313.png)

![img](https://images0.cnblogs.com/blog/650745/201501/181641041515538.png)

 

按照上述操作遍历完所有矩形条之后，栈中的矩形一定是下面这个样子。（栈里面所有的条肯定是按照高度依次递增的）

![img](https://images0.cnblogs.com/blog/650745/201501/181623013086590.png)

此时，对于任何一个矩形条，我们可以确定，它的右边界一定是整个栈里所保留的条形图的最右边界，而它的左边界一定是它这个条自己的左边界，所以，剩余的矩形条也可以立即算出其对应的最大矩形的面积。

![img](https://images0.cnblogs.com/blog/650745/201501/181626122149745.png)

其实，只需要在所有的矩形条最后添加一个高度为0的虚拟矩形条，可以省略上面的两小步。这个虚拟矩形条起收割作用。（见代码第2行）

显然时间复杂度是O(n)。