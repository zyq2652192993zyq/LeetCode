> # 144.Binary Tree Preorder Traversal

Tags: `Medium` `Tree`

Link: <https://leetcode.com/problems/binary-tree-preorder-traversal/>

---

Given a binary tree, return the *preorder* traversal of its nodes' values.

**Example:**

```
Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
```

**Follow up:** Recursive solution is trivial, could you do it iteratively?

---

**Answer:**

二叉树遍历的三种方式：前序遍历、中序遍历、后序遍历，代码实现通常有两种方法：使用栈、Morris遍历法。其中Morris遍历的空间复杂度更优。

* 如果当前节点的左子节点为空时，输出当前节点，并将当前节点置为该节点的右子节点；
* 如果当前节点的左子节点不为空，找到当前节点左子树的最右节点（该节点为当前节点中序遍历的前驱节点）；
* * 如果最右节点的右指针为空(right=null)，将最右节点的右指针指向当前节点，并输出当前节点（在此处输出），当前节点置为其左子节点；
* * 如果最右节点的右指针不为空，将最右节点右指针重新置为空(恢复树的原状)，并将当前节点置为其右节点；
* 重复1~2，直到当前节点为空。

![img](https://img-blog.csdn.net/20150512213400750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveWFuZ2ZlaXNj/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //使用栈的方法，时间复杂度O(n),空间复杂度O(n)
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<const TreeNode *> s;
        const TreeNode *p;
        
        p = root;
        if(p != nullptr) s.push(p);
      
        while(!s.empty()){
            p = s.top();
            s.pop();
            result.push_back(p -> val);
            
            if(p -> right != nullptr) s.push(p -> right);
            if(p -> left != nullptr) s.push(p -> left);
        }
        
        return result;
    }
};
```

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    //Morris遍历方法，时间复杂度O(n),空间复杂度O(1)
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode *> s;
        TreeNode *cur; //当前节点
        
        cur = root;
        while(cur != nullptr){
            if(cur -> left == nullptr){ //当前节点的左子节点为空
                result.push_back(cur -> val); //输出当前节点的值
                cur = cur -> right; //cur设为当前节点的右子节点
            }
            else{ //当前节点的左子节点不为空
                TreeNode *tmp = cur -> left;
                while(tmp -> right != nullptr && tmp -> right != cur){
                    tmp = tmp -> right; //找到当前节点左子树的最右节点
                }
                
                if(tmp -> right == nullptr){ //还没有建立线索
                    result.push_back(cur -> val); //输出当前节点的值
                    tmp -> right = cur;
                    cur = cur -> left;
                }
                else{ //已经建立线索
                    tmp -> right = nullptr; //最右节点的右指针设为空 
                    cur = cur ->right; //将当前节点设为其右节点
                }
            }
        }
        
        return result;
    }
};
```

