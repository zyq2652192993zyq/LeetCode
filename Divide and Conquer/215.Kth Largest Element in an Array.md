> # 215.Kth Largest Element in an Array

Tags: `Heap` `Linked List` `Medium`

Links: <https://leetcode.com/problems/kth-largest-element-in-an-array/>

----

Find the **k**th largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

**Example 1:**

```
Input: [3,2,1,5,6,4] and k = 2
Output: 5
```

**Example 2:**

```
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
```

**Note:**
You may assume k is always valid, 1 ≤ k ≤ array's length.

---

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq;
        for (auto e : nums) pq.push(e);
        
        int res = 0;
        while (k--) {
            res = pq.top();
            pq.pop();
        }
        
        return res;
    }
};
```

此题目的本意不是考最大堆，应该尽可能的考虑用分治法来求解。

但是很显然分治法的时间性能并不是很好。

```c++
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int left = 0, right = nums.size() - 1;
        while (true) {
            int pos = partition(nums, left, right);
            if (pos == k - 1) break;
            else if (pos > k - 1) right = pos - 1;
            else left = pos + 1;
        }
        
        return nums[k - 1];
    }
    
    int partition(vector<int> & nums, int left, int right) {
        int pivot = nums[left], l = left + 1, r = right;
        while (l <= r) {
            if (nums[l] < pivot && nums[r] > pivot) swap(nums[l++], nums[r--]);
            if (nums[l] >= pivot) ++l;
            if (nums[r] <= pivot) --r;
        }
        swap(nums[left], nums[r]);
        
        return r;
    }
};
```

```
Runtime: 80 ms, faster than 11.48% of C++ online submissions for Kth Largest Element in an Array.
Memory Usage: 9.2 MB, less than 87.88% of C++ online submissions for Kth Largest Element in an Array.
```

用到了快速排序 Quick Sort 的思想，这里排序的方向是从大往小排。核心思想是每次都要先找一个中枢点 Pivot，然后遍历其他所有的数字，像这道题从大往小排的话，就把大于中枢点的数字放到左半边，把小于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，虽然左右两部分各自不一定是完全有序的，但是并不影响本题要求的结果，因为左半部分的所有值都大于右半部分的任意值，所以我们求出中枢点的位置，如果正好是 k-1，那么直接返回该位置上的数字；如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；反之则更新右半部分，求中枢点的位置